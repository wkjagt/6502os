ca65 V2.18 - N/A
Main file   : shallow_thought.s
Current file: shallow_thought.s

000000r 1                               .import VIA1_DDRA
000000r 1                               .import VIA1_PORTA
000000r 1                               .import VIA1_DDRB
000000r 1                               .import VIA1_PORTB
000000r 1               
000000r 1                               .import ACIA_DATA
000000r 1                               .import ACIA_CMD
000000r 1               
000000r 1                               .import init_screen
000000r 1                               .import send_byte_to_screen
000000r 1               
000000r 1               NAK             =       $15
000000r 1               ACK             =       $06
000000r 1               EOT             =       $04
000000r 1               SOH             =       $01
000000r 1               
000000r 1               ; kb
000000r 1               KB_CHAR_IN      =       $0
000000r 1               KB_ACK          =       %01000000
000000r 1               RD_SRL_B        =       $838D
000000r 1               
000000r 1                               .zeropage
000000r 1               
000000r 1  xx xx        tmp1:           .res 2
000002r 1  xx xx        tmp2:           .res 2
000004r 1  xx xx        tmp3:           .res 2
000006r 1               
000006r 1                               .code
000000r 1               
000000r 1               screen_init:
000000r 1  20 rr rr                     jsr     init_screen
000003r 1               
000003r 1                               ; startup message
000003r 1  A9 00                        lda     #str_startup
000005r 1  20 rr rr                     jsr     print_string
000008r 1               
000008r 1               kb_init:
000008r 1                               ; data direction on port B
000008r 1  A9 40                        lda     #KB_ACK         ; only the ack pin is output
00000Ar 1  8D rr rr                     sta     VIA1_DDRB
00000Dr 1               
00000Dr 1  A9 01                        lda     #str_any_key
00000Fr 1  20 rr rr                     jsr     print_string
000012r 1               
000012r 1               wait_for_key_press:
000012r 1                               ; The sender starts transmitting bytes as soon as
000012r 1                               ; it receives a NAK byte from the receiver. To be
000012r 1                               ; able to synchronize the two, the workflow is:
000012r 1                               ; 1. start sending command on sender
000012r 1                               ; 2. Press any key on the receiver to start the
000012r 1                               ;    transmission
000012r 1  AD rr rr                     lda     VIA1_PORTB
000015r 1  10 FB                        bpl     wait_for_key_press
000017r 1               
000017r 1                               ; take the key from the buffer and ignore it
000017r 1  20 rr rr                     jsr     receive_nibble
00001Ar 1  20 rr rr                     jsr     receive_nibble
00001Dr 1  20 rr rr                     jsr     receive_nibble
000020r 1               
000020r 1               xmodem_receive:
000020r 1                               ; tell the sender to start sending
000020r 1  A9 15                        lda     #NAK
000022r 1  8D rr rr                     sta     ACIA_DATA
000025r 1               
000025r 1               ; Receiving bytes are done in two nested loops:
000025r 1               ; @next_packet receives xmodem packets of 131 bytes long,
000025r 1               ; including the 128 data bytes, and loops until an EOT byte
000025r 1               ; is received right after a
000025r 1               ; @next_data_byte receives each of the 128 data bytes
000025r 1               @next_packet:
000025r 1  20 rr rr                     jsr     receive_byte    ; receive SOH or EOT
000028r 1  C9 04                        cmp     #EOT
00002Ar 1  F0 20                        beq     @eot
00002Cr 1               
00002Cr 1  C9 01                        cmp     #SOH
00002Er 1  F0 00                        beq     @continue_header
000030r 1               
000030r 1                               ; todo: error if ending up here?
000030r 1               @continue_header:
000030r 1  20 rr rr                     jsr     receive_byte    ; packet sequence number
000033r 1  20 rr rr                     jsr     receive_byte    ; packet sequence number checksum
000036r 1                               ; todo: add up and check if 0
000036r 1               
000036r 1  A0 80                        ldy     #128            ; 128 data bytes
000038r 1               @next_data_byte:
000038r 1  20 rr rr                     jsr     receive_byte
00003Br 1  20 rr rr                     jsr     print_formatted_byte_as_hex
00003Er 1               
00003Er 1  88                           dey
00003Fr 1  D0 F7                        bne     @next_data_byte
000041r 1               
000041r 1  20 rr rr                     jsr     receive_byte    ; receive the data packet checksum
000044r 1               
000044r 1                               ; todo: verify checksum and send ACK or NAK
000044r 1               
000044r 1  A9 06                        lda     #ACK
000046r 1  8D rr rr                     sta     ACIA_DATA
000049r 1               
000049r 1  4C rr rr                     jmp     @next_packet
00004Cr 1               @eot:
00004Cr 1  A9 06                        lda     #ACK
00004Er 1  8D rr rr                     sta     ACIA_DATA
000051r 1  60                           rts
000052r 1               
000052r 1               receive_byte:
000052r 1                               ; reading a byte through serial connection
000052r 1                               ; is wrapped in turning DTR on and off. However
000052r 1                               ; it seems to not completely work, since we still
000052r 1                               ; need a short pause between the bytes when sending.
000052r 1  A9 CB                        lda     #%11001011      ; terminal ready
000054r 1  8D rr rr                     sta     ACIA_CMD
000057r 1               
000057r 1  20 8D 83                     jsr     RD_SRL_B        ; blocking
00005Ar 1  48                           pha
00005Br 1               
00005Br 1  A9 CA                        lda     #%11001010      ; terminal not ready
00005Dr 1  8D rr rr                     sta     ACIA_CMD
000060r 1               
000060r 1  68                           pla
000061r 1  60                           rts
000062r 1               
000062r 1               ; this only adds a space
000062r 1               print_formatted_byte_as_hex:
000062r 1  20 rr rr                     jsr     print_byte_as_hex
000065r 1  A9 20                        lda     #' '
000067r 1  20 rr rr                     jsr     send_byte_to_screen
00006Ar 1  60                           rts
00006Br 1               
00006Br 1               print_byte_as_hex:
00006Br 1  48                           pha                     ; keep a copy for the low nibble
00006Cr 1               
00006Cr 1  4A                           lsr                     ; shift high nibble into low nibble
00006Dr 1  4A                           lsr
00006Er 1  4A                           lsr
00006Fr 1  4A                           lsr
000070r 1               
000070r 1  20 rr rr                     jsr     print_nibble
000073r 1               
000073r 1  68                           pla                     ; get original value back
000074r 1  29 0F                        and     #%00001111      ; reset high nibble
000076r 1  20 rr rr                     jsr     print_nibble
000079r 1  60                           rts
00007Ar 1               
00007Ar 1               print_nibble:
00007Ar 1  C9 0A                        cmp     #10
00007Cr 1  B0 05                        bcs     @letter         ; >= 10 (hex letter A-F)
00007Er 1  69 30                        adc     #48             ; ASCII offset to numbers 0-9
000080r 1  4C rr rr                     jmp     @print
000083r 1               @letter:
000083r 1  69 36                        adc     #54             ; ASCII offset to letters A-F
000085r 1               @print:
000085r 1  20 rr rr                     jsr     send_byte_to_screen
000088r 1  60                           rts
000089r 1               
000089r 1               receive_nibble:
000089r 1  AD rr rr                     lda     VIA1_PORTB        ; LDA loads bit 7 (avail) into N
00008Cr 1                               ; move low nibble from PORT B to high nibble
00008Cr 1  0A                           asl
00008Dr 1  0A                           asl
00008Er 1  0A                           asl
00008Fr 1  0A                           asl
000090r 1               
000090r 1  A2 04                        ldx     #4
000092r 1               @rotate:
000092r 1  0A                           asl                     ; shift bit into carry
000093r 1  26 00                        rol     KB_CHAR_IN      ; rotate carry into CHAR
000095r 1  CA                           dex
000096r 1  D0 FA                        bne     @rotate
000098r 1               
000098r 1  AD rr rr                     lda     VIA1_PORTB        ; send ack signal to kb controller
00009Br 1  09 40                        ora     #KB_ACK
00009Dr 1  8D rr rr                     sta     VIA1_PORTB
0000A0r 1               @wait_avail_low:
0000A0r 1  AD rr rr                     lda     VIA1_PORTB        ; wait for available to go low
0000A3r 1  30 FB                        bmi     @wait_avail_low ; negative means bit 7 (avail) high
0000A5r 1               
0000A5r 1  AD rr rr                     lda     VIA1_PORTB           ; set ack low
0000A8r 1  29 00                        and     #!KB_ACK
0000AAr 1  8D rr rr                     sta     VIA1_PORTB
0000ADr 1  60                           rts
0000AEr 1               
0000AEr 1               print_string:
0000AEr 1  0A                           asl                     ; multiply by 2 because size of memory address is 2 bytes
0000AFr 1  A8                           tay
0000B0r 1  B9 rr rr                     lda     string_table,y  ; string index into string table
0000B3r 1  85 rr                        sta     tmp3            ; LSB
0000B5r 1  C8                           iny
0000B6r 1  B9 rr rr                     lda     string_table,y
0000B9r 1  85 rr                        sta     tmp3+1          ; MSB
0000BBr 1               
0000BBr 1  A0 00                        ldy #0
0000BDr 1               @next_char:
0000BDr 1  B1 rr                        lda (tmp3),y
0000BFr 1  F0 06                        beq @done
0000C1r 1               
0000C1r 1  20 rr rr                     jsr send_byte_to_screen
0000C4r 1  C8                           iny
0000C5r 1  80 F6                        bra @next_char
0000C7r 1               @done:
0000C7r 1  A9 0D                        lda     #$0d
0000C9r 1  20 rr rr                     jsr     send_byte_to_screen
0000CCr 1  A9 0A                        lda     #$0a
0000CEr 1  20 rr rr                     jsr     send_byte_to_screen
0000D1r 1  60                           rts
0000D2r 1               
0000D2r 1               ; strings ========================================
0000D2r 1               
0000D2r 1               str_startup     =       0
0000D2r 1               str_any_key     =       1
0000D2r 1               
0000D2r 1               string_table:
0000D2r 1  rr rr rr rr                  .word s_startup, s_any_key
0000D6r 1               
0000D6r 1  53 68 61 6C  s_startup:      .byte "Shallow Thought v0.01", 0
0000DAr 1  6C 6F 77 20  
0000DEr 1  54 68 6F 75  
0000ECr 1  50 72 65 73  s_any_key:      .byte "Press any key", 0
0000F0r 1  73 20 61 6E  
0000F4r 1  79 20 6B 65  
0000F9r 1               
